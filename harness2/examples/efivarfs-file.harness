#include "linux/kconfig.h"
#include "linux/compiler_types.h"
#include "asm/orc_header.h"
#include "linux/build-salt.h"
#include "linux/elfnote-lto.h"
#include "linux/export-internal.h"
#include "linux/module.h"
#include "linux/efi.h"
#include "linux/delay.h"
#include "fs/efivarfs/internal.h"

extern const struct file_operations efivarfs_file_operations;

@S('client_inactive_state')
@S('client_active_state')

@A('client_open_file')
@A('client_close_file')
@A('client_read_file')
@A('client_write_file')

@E(client_inactive_state, client_inactive_state, nil, nil)
@E(client_inactive_state, client_active_state, nil, client_open_file)
@E(client_active_state, client_active_state, nil, client_read_file)
@E(client_active_state, client_active_state, nil, client_write_file)
@E(client_active_state, client_inactive_state, nil, client_close_file)

@P('client1', client_inactive_state)
@P('client2', client_inactive_state)
@clients = { client1, client2 }

@for _, client in pairs(clients) do
    client:setup([[
        struct efivar_entry entry;
        struct inode inode = { .i_private = &entry };
        struct file file;
        char buf[128];
    ]])
end

@client_open_file:exec([[
    efivarfs_file_operations.open(&inode, &file);
]])
@client_close_file:exec([[
    efivarfs_file_operations.release(&inode, &file);
]])
@client_read_file:exec([[
    loff_t pos;
    efivarfs_file_operations.read(&file, buf, sizeof(buf), &pos);
]])
@client_write_file:exec([[
    loff_t pos;
    efivarfs_file_operations.write(&file, buf, sizeof(buf), &pos);
]])